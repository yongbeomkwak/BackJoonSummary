#include <bits/stdc++.h>

using namespace std;

#define MAX 101
#define MOD 1000000000

int n;
int dp[MAX][10][1 << 10]; // dp[101][10][1024]  dp[길이][0~9(현재 숫자)][0~9까지 사용했는지 체크비트(10개)]

int main()
{
    int n;
    cin >> n;

    int full = (1 << 10) - 1; // 모든 비트가 켜져있다. 1111111111 (2^10-1)

    // 0을 제외한 1~9까지를 1로 초기화한다. 0은 시작 숫자가 될 수 없기 때문에 제거한다.
    for (int i = 1; i <= 9; i++)
    {
        dp[1][i][1 << i] = 1; //길이 1일 때 i를 사용,[1<<i](해당 비트 켜줌)
    }

    /*
     0000000000 ~ 1111111111 까지의 모든 이전 단계의 숫자사용 여부를 기준으로 다음 단계의 가능한 다음 단계로 넘겨준다.
      0 과 9가 아닐 경우에는 하나씩, 현재 자리수 +1, -1 을 한 이전 높이의 두 개를 수행한다.
      최외곽의 for문 변수가 하나씩 증가할때마다 깊이가 증가하기 때문에, bfs와 유사한 구조이다.
    */
    for (int i = 2; i <= n; i++) //길이 2부터 n까지 계산
    {
        for (int j = 0; j <= 9; j++) // 0~9까지
        {
            for (int k = 0; k <= full; ++k)
            { //비트 켜기.

                if (j == 0)
                    dp[i][0][k | (1 << 0)] = (dp[i][0][k | (1 << 0)] + dp[i - 1][1][k]) % MOD; //이전 길이에서 1을 썼나?

                else if (j == 9)
                    dp[i][9][k | (1 << 9)] = (dp[i][9][k | (1 << 9)] + dp[i - 1][8][k]) % MOD; //이전 길이 8을 사용했나?

                else
                {
                    // [k|(1<<j)] 해당 비트 켜기
                    dp[i][j][k | (1 << j)] = (dp[i][j][k | (1 << j)] + dp[i - 1][j - 1][k]) % MOD; //이전 숫자가 켜져있으면
                    dp[i][j][k | (1 << j)] = (dp[i][j][k | (1 << j)] + dp[i - 1][j + 1][k]) % MOD; //이전 숫자가 켜져있고 다음 숫자가 켜져있으면
                }
            }
        }
    }
    int ans = 0;
    for (int i = 0; i <= 9; ++i)
        ans = (ans + dp[n][i][full]) % MOD;

    cout << ans;
}
