#   BackTracking
##      백트래킹
-   모든 경우의 수를 전부 고려하는 알고리즘. 상태공간을 트리로 나타낼 수 있을 때 적합한 방식이다. 일종의 트리 탐색 알고리즘이라고 봐도 된다. 방식에 따라서 깊이우선탐색(Depth First Search, DFS)과 너비우선탐색(Breadth First Search, BFS), 최선 우선 탐색(Best First Search/Heuristic Search)이 있다. 그냥 뇌없이 짤 수 있다는 것이 장점이다.

-   모든 경우의 수를 고려해야 하는 문제라면, DFS가 낫다. BFS로도 구현이 물론 가능하지만, BFS로 구현했다간 큐의 크기가 심지어 속도도 똑같다. 따라서 경우의 수 구하기는 일반적으로 DFS가 편리하다. 대다수의 문제들은 DFS를 써도 일단 답은 나온다.

 
 ## 1.   **DFS** 
 는 상태공간을 나타낸 트리에서 바닥에 도달할 때까지 한 쪽 방향으로만 내려가는 방식이다. 미로찾기를 생각하면 쉽다. 한 방향으로 들어갔다가 막다른 길에 다다르면(=트리의 바닥에 도착) 왔던 길을 돌아가서 다른 방향으로 간다.
 
  이 짓을 목표지점(=원하는 해)이 나올 때까지 반복한다.

재귀함수로 구현할 수 있으며, 재귀함수에 익숙하지 않다면 스택을 써서 할 수도 있다.사실 재귀가 코딩 분량도 적고 직관적이다

## 2.   **BFS**
BFS는 모든 분기점을 다 검사하면서 진행하는 방식이다. 
 
 BFS는 큐를 써서 구현한다. 각 경우를 검사하면서 발생하는 새로운 경우를 큐에 집어넣고, 검사한 원소는 큐에서 뺀다. BFS의 장점은 DFS가 못 건드리는 문제를 풀 수 있는 것이지만, 공간 복잡도가 지수 스케일로 폭발하기 때문에 가지치기를 제대로 안하면 DFS보다 빨리 오버플로우에 다다를 수 있다.

 BFS에서 조금 더 발전한 방식이 Best First Search 방식이다. 큐 대신 우선순위 큐(보통은 힙으로 구현되는)를 써서 구현하는데, 발생하는 새로운 경우를 순차적으로 검사하는 Breadth First Search와는 달리 현재 가장 최적인 경우를 우선적으로 검사하므로 상대적으로 효율적이다. 백트래킹은 모든 경우를 다 고려하기 때문에 귀찮을때 이걸 쓰면 어지간해서는 해결할 수도 있다

 ###    1) 15650
 -  중복없는 순열(permutation)의 오름차순

###     2)9663
-   체스    Queen
-   for문의 대각선 이동 방법

###   3)2580
- 한 줄 입력 받아 각 입력을 배열에 넣는 방법 사용
- 한 줄 입력 getline(cin,stirng object)
- 문자 하나씩 뽑아내기 sstream에 있는 istringstream
- find(시작점,끝점,찾을값) - > 찾을 시 해당 위치(iterator) , 못찾을 시 end를 가르침
- vector.erase(it)-> 해당 iterator가 가르키는 값 벡터에서 제거