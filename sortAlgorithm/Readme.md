#   SortAlogithm

##  1.  2751
- ### **MergeSort**
-   개념: 주어진 배열 또는 collection을 계속 절반식 나눠 2개씩만 남았을 때 정렬을 시작한다
-   구현 컨셉: **재귀** 및 **새로운 메모리 할당**(new keyword)을 해줘야함
-   *시간복잡도*: *n log n* ,  log n(한번 실행 절반으로 분할)  X n(n번 비교)
-   구성은 중간에서 분할 및 병합 과정을 2개의 함수로 나눠서 정의한다
___
## 2.10989_2 ,10989
- 10989는 메모리를 감소를 위한 구조, 10989_2는 정의에 충실히 구현
- ### **CountingSort**
-   개념: 주어진 배열 각 원소에 해당하는 count배열 원소를 1씩 증가 시킨다  이 후 그 갯수를 이용하여 부분합으로 바꾼다.
-   해당 부분합을 결과 배열에 위치로 이용하여 입렵배열 값을 옮긴다. 
-   구현 컨셉:**계수 정렬**은 우리가 배운 알고리즘 중에 처음으로 **비교 정렬**이 아닙니다. 이전까지는 두 수를 비교하여 정렬했다면 이 방법은 단 하나의 비교도 일어나지 않았습니다. 그리고 같은 숫자라도 정렬할 때 순서가 섞이지 않는 **안정 정렬**입니다.
-   *시간복잡도*: *O(n+k)* ,  k는 입력값 중 가장 큰 값
-   *입력 범위가 크지 않을 경우 효율 적* 
___
## 3.2108
-  Map,Pair,Vector를 이용하여 아래 통계값 구하기
-  정렬함수와 Map을 이용하여 pair 객체 접근시 first와 second를 자세히 봐라 
-  산술평균 : N개의 수들의 합을 N으로 나눈 값
-   중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값
-   최빈값 : N개의 수들 중 가장 많이 나타나는 값
-   범위 : N개의 수들 중 최댓값과 최솟값의 차이
-   ___
## 3.quick_sort
- ### **QuickSort**
-   개념: 주어진 배열에서 중간값을 잡은 후 **(여기서 중간값은 크기로 중간값이 가장 좋지만 검색을 해야하기 때문에 물리적인 중간값(인덱스)로 잡는다.)** 중간값보다 작은 값은 왼쪽에 큰쪽은 오른 쪽에 정렬한다 

-   구현 컨셉: 시작값과 끝값의 포인터를 중앙으로 계속 이동 시킨다

    시작값이 가르키는 값이 피벗(중간값) 보다 크거나같으면 멈춤
    끝값은 가르키는 값이 피벗(중간값)보다 작거나 같으면 멈춤
    둘다 멈춘 후 시작값이 끝값이 지나치지 않았을 때(start<=end) 가르키는 두 값을 swap 한다
    swap이후 서로 지나쳐감
    지나쳤다는 것은(start<=end)가 성립 안하니 다음 파티션으로 넘어간다

-   *시간복잡도*: *O(n log n )* ,  WorstCase는 O(n^2): 중간 값이 계속 가장 작은 값 또는 큰 값 일 때
___
## 4.1181
-   개념:사전순 정렬 및 중복값 제거
-   구현 컨셉:string와 vecotr(erase와 **unique**)사용
-   중복값제거:erase 와 unique를 사용 그 대신 반드시 정렬을 해야함 (uniqure의 특징 때문) 
